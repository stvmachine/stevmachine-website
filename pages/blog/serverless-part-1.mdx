---
title: "Starting with Serverless- Part 1"
publishedAt: "2021-01-12"
summary: "Installation and a start a new project"
tags:
  - serverless
  - cloud
---

## Table of Contents

- [Pre-requisites](#pre-requisites)
- [Start a new project](#start-a-new-project)
- [Run server](#run-server)
- [Resources](#resources)

## Pre-requisites

1. Install serverless

```bash
npm install serverless -g
```

2. Configure your [AWS credentials](https://www.serverless.com/framework/docs/providers/aws/guide/credentials/).

3. _(Optional)_ Setup Dynamodb locally

My preferred way to use DynamoDB is through _docker-compose_. For that, we would need to create a `docker-compose.yml` in the root of the project:

```yaml
version: "3.5"

services:
  dynamo:
    container_name: local-dynamodb
    image: amazon/dynamodb-local
    networks:
      - local-dynamodb
    ports:
      - "8000:8000"
    volumes:
      - dynamodata:/home/dynamodblocal
    working_dir: /home/dynamodblocal
    command: "-jar DynamoDBLocal.jar -sharedDb -dbPath ."

networks:
  local-dynamodb:
    name: local-dynamodb

volumes:
  dynamodata: {}
```

> Take the use of local dynamodb with a grain of salt due it doesn't have the same performance and it doesn't include all the features than its counterpart through AWS. So, just use it as a starting point and be aware of possible bugs or inconsistencies.
> For more ways to setup dynamodb and more information in general you can take a look here: https://dynobase.dev/run-dynamodb-locally/#docker-compose

## Step 1: Let's create a Node.js serverless project

```
$ serverless create --template aws-nodejs --path candidate-service --name candidate
```

This will create the directory `candidate-service` with the following structure:

```
.
├── .npmignore
├── handler.js
└── serverless.yml
```

Let's look at each of these three files one by one.

- `.npmignore`: This file is used to tell npm which files should be kept outside of the package.
- `handler.js`: This declares your Lambda function. The created Lambda function returns a body with `Go Serverless v1.0! Your function executed successfully!` message.
- `serverless.yml`: This file declares configuration that Serverless Framework uses to create your service. serverless.yml file has three sections — provider, functions, and resources.
  - provider: This section declares configuration specific to a cloud provider. You can use it to specify name of the cloud provider, region, runtime etc.
  - functions: This section is used to specify all the functions that your service is composed off. A service can be composed of one or more functions.
  - resources: This section declares all the resources that your functions use. Resources are declared using AWS CloudFormation.

## Step 2: Create a REST resource

Let's update the `serverless.yml` to handle POST to `/candidates`:

```yml
service: candidate-service

frameworkVersion: "2"

provider:
  name: aws
  runtime: nodejs12.x

functions:
  candidateSubmission:
    handler: api/candidate.submit
    memorySize: 128
    description: Submit candidate information and starts interview process.
    events:
      - http:
          path: candidates
          method: post
```

Then, we refactor a bit the file structure and we rename `handler.js` to `api/candidate.js`. Inside of this file, we define our functions, in this case `candidate.submit`:

```js
"use strict";

module.exports.submit = (event, context, callback) => {
  const response = {
    statusCode: 200,
    body: JSON.stringify({
      message: "Go Serverless v1.0! Your function executed successfully!",
      input: event,
    }),
  };

  callback(null, response);
};
```

We are ready to deploy:

```
sls deploy
```

```Serverless: Packaging service...
Serverless: Excluding development dependencies...
Serverless: Creating Stack...
Serverless: Checking Stack create progress...
........
Serverless: Stack create finished...
Serverless: Ensuring that deployment bucket exists
Serverless: Uploading CloudFormation file to S3...
Serverless: Uploading artifacts...
Serverless: Uploading service candidate.zip file to S3 (587 B)...
Serverless: Validating template...
Serverless: Updating Stack...
Serverless: Checking Stack update progress...
..............................
Serverless: Stack update finished...
Service Information
service: candidate
stage: dev
region: us-east-1
stack: candidate-dev
resources: 11
api keys:
  None
endpoints:
  POST - https://3hlhmtm7cf.execute-api.us-east-1.amazonaws.com/dev/candidates
functions:
  candidateSubmission: candidate-dev-candidateSubmission
layers:
  None
```

Now, POST operation of your service is available. You can use tools like cURL to make a POST request.

```bash
$curl -X POST https://3hlhmtm7cf.execute-api.us-east-1.amazonaws.com/dev/candidates

{"message":"Go Serverless v1.0! Your function executed successfully!", "input":{...}}
```

## Step 3: Saving data to DynamoDB

We are going to add two tables: `candidate` and `candidate_email` to DynamoDB. To do that we need to update `serverless.yml` adding the section _environment_ and _iamRoleStatements_.

```yml
provider:
  name: aws
  runtime: nodejs12.x
  environment:
    CANDIDATE_TABLE: ${self:service}-${opt:stage, self:provider.stage}
    CANDIDATE_EMAIL_TABLE: "candidate-email-${opt:stage, self:provider.stage}"
  iamRoleStatements:
    - Effect: Allow
      Action:
        - dynamodb:Query
        - dynamodb:Scan
        - dynamodb:GetItem
        - dynamodb:PutItem
      Resource: "*"
```

Next, we'll create a resource that will create DynamoDB table as shown below.

```yml
resources:
  Resources:
    CandidatesDynamoDbTable:
      Type: "AWS::DynamoDB::Table"
      DeletionPolicy: Retain
      Properties:
        AttributeDefinitions:
          - AttributeName: "id"
            AttributeType: "S"
        KeySchema:
          - AttributeName: "id"
            KeyType: "HASH"
        ProvisionedThroughput:
          ReadCapacityUnits: 1
          WriteCapacityUnits: 1
        StreamSpecification:
          StreamViewType: "NEW_AND_OLD_IMAGES"
        TableName: ${self:provider.environment.CANDIDATE_TABLE}
```

Now, you can deploy the function as shown below.

```bash
serverless deploy --verbose
```

And we can create a new candidate running:

```bash
curl -H "Content-Type: application/json" -X POST -d '{"fullname":"Esteban Campos","email": "campos.esteban@gmail.com", "experience":6}'

https://il2r2hckl5.execute-api.us-east-1.amazonaws.com/dev/candidates
```

## Step 4: List all the candidates

Let's add a new function to our `serverless.yml`.

```yaml
listCandidates:
  handler: api/candidate.list
  memorySize: 128
  description: List all candidates
  events:
    - http:
        path: candidates
        method: get
```

We also need to add the implementation in the API:

```js
module.exports.list = (event, context, callback) => {
  var params = {
    TableName: process.env.CANDIDATE_TABLE,
    ProjectionExpression: "id, fullname, email",
  };

  console.log("Scanning Candidate table.");
  const onScan = (err, data) => {
    if (err) {
      console.log(
        "Scan failed to load data. Error JSON:",
        JSON.stringify(err, null, 2)
      );
      callback(err);
    } else {
      console.log("Scan succeeded.");
      return callback(null, {
        statusCode: 200,
        body: JSON.stringify({
          candidates: data.Items,
        }),
      });
    }
  };

  dynamoDb.scan(params, onScan);
};
```

And then we are able to use the function using cURL:

```bash
$curl -H "Content-Type: application/json" -X GET https://il2r2hckl5.execute-api.us-east-1.amazonaws.com/dev/candidates

{"candidates":[{"email":"campos.esteban@gmail.com","id":"c21c4c80-7299-11ec-86f3-234be33cf5b5","fullname":"Esteban Campos"}
```

## Step 5: Get Candidate Details by ID

Define a new function in serverless.yml as shown below.

```yaml
candidateDetails:
  handler: api/candidate.get
  events:
    - http:
        path: candidates/{id}
        method: get
```

Define a new function in api/candidate.js

```js
module.exports.get = (event, context, callback) => {
  const params = {
    TableName: process.env.CANDIDATE_TABLE,
    Key: {
      id: event.pathParameters.id,
    },
  };

  dynamoDb
    .get(params)
    .promise()
    .then((result) => {
      const response = {
        statusCode: 200,
        body: JSON.stringify(result.Item),
      };
      callback(null, response);
    })
    .catch((error) => {
      console.error(error);
      callback(new Error("Couldn't fetch candidate."));
      return;
    });
};
```

And we can test the function as well:

```bash
$curl -H "Content-Type: application/json" -X GET   https://il2r2hckl5.execute-api.us-east-1.amazonaws.com/dev/candidates/c21c4c80-7299-11ec-86f3-234be33cf5b5

{"experience":6,"updatedAt":1641876525384,"id":"c21c4c80-7299-11ec-86f3-234be33cf5b5","email":"campos.esteban@gmail.com","fullname":"Esteban Campos","submittedAt":1641876525384}
```

## Resources

- [Building a REST API in Node.js with AWS Lambda, API Gateway, DynamoDB, and Serverless Framework](https://www.serverless.com/blog/node-rest-api-with-serverless-lambda-and-dynamodb)
- [How to run DynamoDB Local and Offline - Complete Guide](https://dynobase.dev/run-dynamodb-locally/#docker-compose)
